//+------------------------------------------------------------------+
//| EA_SmartMoney_Skeleton.mq5                                       |
//| Minimal Smart Money Concepts skeleton for MT5 (educational)      |
//| NOT financial advice â€” backtest on demo before using live.       |
//+------------------------------------------------------------------+
#property copyright "copilot"
#property version   "0.1"
#property strict

input double RiskPercent = 1.0;            // % risk per trade
input double FixedLot   = 0.0;             // if >0 uses fixed lot, otherwise uses risk percent
input int    Slippage   = 5;
input int    TFMinutes  = PERIOD_M15;      // timeframe used by EA logic (chart can differ)
input double MinFVGSize = 5.0;             // minimum gap in points for Fair Value Gap
input int    LookbackBars = 50;            // how many bars to scan for zones
input double TakeProfitRR = 2.0;           // take profit as RR of stop distance
input bool   UseOnlyFVGandOB = true;       // only open trades when both detected

//--- globals
int g_magic = 20251117;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
   // nothing special for now
   return(INIT_SUCCEEDED);
  }

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
  }

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
   static datetime lastCheck = 0;
   MqlRates rates[];
   int copied = CopyRates(_Symbol, TFMinutes, 0, LookbackBars, rates);
   if(copied <= 10) return;

   // Run once per new bar on TFMinutes
   datetime t = rates[0].time;
   if(t == lastCheck) return;
   lastCheck = t;

   // 1) Check market structure (simple): look for last higher high / lower low break
   int structure = DetectSimpleStructure(rates, copied); // 1=bull, -1=bear, 0=unknown

   // 2) Find latest Fair Value Gap (FVG)
   bool fvgFound = false;
   double fvgHigh=0, fvgLow=0;
   int fvgBarIndex = -1;
   FindLatestFVG(rates, copied, MinFVGSize, fvgFound, fvgHigh, fvgLow, fvgBarIndex);

   // 3) Find simple Order Block candidate
   bool obFound = false;
   double obHigh=0, obLow=0;
   int obBarIndex = -1;
   FindSimpleOrderBlock(rates, copied, obFound, obHigh, obLow, obBarIndex);

   // 4) Determine entry: retest into zone
   if(fvgFound && obFound && MathAbs(structure) > 0)
     {
      // require both zones if configured
      if(UseOnlyFVGandOB)
        {
         // Example bullish case: structure bullish, look for price retest into zone
         if(structure == 1)
           {
            // price must be above OB/FVG and then come back into them (retest)
            double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            if(PriceRetestedBullish(price, fvgLow, obLow))
              {
               // prepare to buy
               double sl = MathMin(fvgLow, obLow) - 10*_Point; // padding
               double tp = price + (price - sl) * TakeProfitRR;
               double lot = CalculateLotSize(sl, price);
               if(lot > 0)
                 {
                  SendOrder(ORDER_TYPE_BUY, lot, price, sl, tp);
                 }
              }
           }
         else if(structure == -1)
           {
            double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
            if(PriceRetestedBearish(price, fvgHigh, obHigh))
              {
               double sl = MathMax(fvgHigh, obHigh) + 10*_Point;
               double tp = price - (sl - price) * TakeProfitRR;
               double lot = CalculateLotSize(sl, price);
               if(lot > 0)
                 {
                  SendOrder(ORDER_TYPE_SELL, lot, price, sl, tp);
                 }
              }
           }
        }
     }
  }

//+------------------------------------------------------------------+
//| --- Utility & detection functions                                |
//+------------------------------------------------------------------+
// Very simplistic structure detection: checks if last swing high > prior swing high (bull) or vice versa
int DetectSimpleStructure(const MqlRates rates[], int count)
  {
   // Find last two swing highs/lows (very simple)
   double lastHigh = rates[1].high;
   double prevHigh = rates[2].high;
   double lastLow  = rates[1].low;
   double prevLow  = rates[2].low;
   if(lastHigh > prevHigh && lastLow > prevLow) return 1;
   if(lastHigh < prevHigh && lastLow < prevLow) return -1;
   return 0;
  }

// Find the most recent Fair Value Gap (3-candle gap where middle candle doesn't overlap neighbors)
// This is a simple FVG definition for illustration
void FindLatestFVG(const MqlRates rates[], int count, double minSizePoints, bool &found, double &high, double &low, int &barIndex)
  {
   found = false; high = low = 0; barIndex = -1;
   for(int i=1;i<count-2;i++)
     {
      double leftHigh = rates[i+1].high;
      double leftLow  = rates[i+1].low;
      double midHigh  = rates[i].high;
      double midLow   = rates[i].low;
      double rightHigh = rates[i-1].high;
      double rightLow  = rates[i-1].low;
      // bullish gap: mid candle completely below neighbors' lows/high? simplified:
      if(midHigh < leftLow && midHigh < rightLow)
        {
         double gap = MathMin(leftLow, rightLow) - midHigh;
         if(gap >= minSizePoints*_Point)
           {
            found = true;
            high = MathMin(leftLow, rightLow);
            low = midHigh;
            barIndex = i;
            return;
           }
        }
      // bearish gap:
      if(midLow > leftHigh && midLow > rightHigh)
        {
         double gap = midLow - MathMax(leftHigh, rightHigh);
         if(gap >= minSizePoints*_Point)
           {
            found = true;
            high = midLow;
            low = MathMax(leftHigh, rightHigh);
            barIndex = i;
            return;
           }
        }
     }
  }

// Very simplistic order block detection: last bearish candle before bullish strong move or vice versa
void FindSimpleOrderBlock(const MqlRates rates[], int count, bool &found, double &high, double &low, int &barIndex)
  {
   found = false; high = low = 0; barIndex = -1;
   for(int i=2;i<count-1;i++)
     {
      // bullish OB: a bearish candle followed by a large bullish candle
      if(rates[i].close < rates[i].open && rates[i-1].close > rates[i-1].open)
        {
         double body = MathAbs(rates[i-1].close - rates[i-1].open);
         double prevBody = MathAbs(rates[i].open - rates[i].close);
         if(body > prevBody*1.2) // simple size check
           {
            found = true;
            high = rates[i].high;
            low  = rates[i].low;
            barIndex = i;
            return;
           }
        }
      // bearish OB: bullish candle followed by large bearish candle
      if(rates[i].close > rates[i].open && rates[i-1].close < rates[i-1].open)
        {
         double body = MathAbs(rates[i-1].close - rates[i-1].open);
         double prevBody = MathAbs(rates[i].open - rates[i].close);
         if(body > prevBody*1.2)
           {
            found = true;
            high = rates[i].high;
            low  = rates[i].low;
            barIndex = i;
            return;
           }
        }
     }
  }

bool PriceRetestedBullish(double price, double fvgLow, double obLow)
  {
   // price retest heuristic: price dipped into zone within last bar
   MqlRates last;
   if(CopyRates(_Symbol, TFMinutes, 0, 1, last) <= 0) return false;
   double low = MathMin(fvgLow, obLow);
   if(last.low <= low + 10*_Point) return true;
   return false;
  }

bool PriceRetestedBearish(double price, double fvgHigh, double obHigh)
  {
   MqlRates last;
   if(CopyRates(_Symbol, TFMinutes, 0, 1, last) <= 0) return false;
   double high = MathMax(fvgHigh, obHigh);
   if(last.high >= high - 10*_Point) return true;
   return false;
  }

double CalculateLotSize(double stopLevel, double entryPrice)
  {
   if(FixedLot > 0.0) return(NormalizeDouble(FixedLot,2));
   // risk percent method: risk in account currency
   double slPoints = MathAbs(entryPrice - stopLevel) / _Point;
   if(slPoints <= 0) return 0;
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   // approximate: risk money = balance * (RiskPercent/100)
   double riskMoney = AccountInfoDouble(ACCOUNT_BALANCE) * (RiskPercent/100.0);
   // value per point per lot (approx) = tickValue / tickSize
   double valuePerPointPerLot = tickValue / tickSize;
   double lot = riskMoney / (slPoints * valuePerPointPerLot);
   // clamp to allowed sizes
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double step   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   if(lot < minLot) return 0;
   if(lot > maxLot) lot = maxLot;
   // normalize to step
   double rounded = MathFloor(lot/step)*step;
   return(NormalizeDouble(rounded,2));
  }

void SendOrder(ENUM_ORDER_TYPE type, double volume, double price, double sl, double tp)
  {
   MqlTradeRequest req;
   MqlTradeResult  res;
   ZeroMemory(req);
   ZeroMemory(res);
   req.magic = g_magic;
   req.deviation = Slippage;
   req.volume = volume;
   req.type_filling = ORDER_FILLING_FOK;
   req.type_time = ORDER_TIME_GTC;
   if(type == ORDER_TYPE_BUY)
     {
      req.action = TRADE_ACTION_DEAL;
      req.type = ORDER_TYPE_BUY;
      req.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      req.sl = sl;
      req.tp = tp;
     }
   else
     {
      req.action = TRADE_ACTION_DEAL;
      req.type = ORDER_TYPE_SELL;
      req.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      req.sl = sl;
      req.tp = tp;
     }

   if(!OrderSend(req,res))
     {
      PrintFormat("OrderSend failed: result=%d retcode=%d", (int)res.retcode, res.retcode);
     }
   else
     {
      PrintFormat("OrderSend succeeded: ticket=%I64d", res.order);
     }
  }

//+------------------------------------------------------------------+
